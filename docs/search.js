window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "tangles_tot", "modulename": "tangles_tot", "kind": "module", "doc": "<h1 id=\"installation\">Installation</h1>\n\n<ol>\n<li>Install the tot-dev environment from the environment.yml and activate it</li>\n<li>Clone the tangles library from <a href=\"https://github.com/tangle-software/tangles.git\">https://github.com/tangle-software/tangles.git</a></li>\n<li>Install the tangles library or add it to the path</li>\n</ol>\n\n<h1 id=\"examples\">Examples</h1>\n\n<p>Interactive jupyter notebooks showing and explaining the usage of the library can be found in the <code>examples</code> folder. </p>\n\n<h1 id=\"tests\">Tests</h1>\n\n<p>You can validate that you have all necessary dependencies by running our test suite.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pytest\n</code></pre>\n</div>\n\n<h1 id=\"documentation\">Documentation</h1>\n\n<p>The Documentation can be found in the docs folder. </p>\n\n<p>It is generated using nbconvert and pdoc with the following command.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>./docs/build_documentation.sh\n</code></pre>\n</div>\n"}, {"fullname": "tangles_tot.features", "modulename": "tangles_tot.features", "kind": "module", "doc": "<p>This package provides tools for working with features in the context of the tree of tangles.\nIt contains functionality for reconstructing interpretations for the corners added to a feature system\nby the tree of tangles uncrossing algorithm.</p>\n"}, {"fullname": "tangles_tot.features.TextTerm", "modulename": "tangles_tot.features", "qualname": "TextTerm", "kind": "class", "doc": "<p>Class representing a text-based logical term with operations.</p>\n"}, {"fullname": "tangles_tot.features.TextTerm.__init__", "modulename": "tangles_tot.features", "qualname": "TextTerm.__init__", "kind": "function", "doc": "<p>Initialize a TextTerm instance.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text:</strong>  The text content of the term.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">_outer_operation</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "tangles_tot.features.TextTerm.build_from", "modulename": "tangles_tot.features", "qualname": "TextTerm.build_from", "kind": "function", "doc": "<p>Build a TextTerm from various possible source types.</p>\n\n<p>Can either be a string or TextTerm directly or a MetaData object.\nIn case of source being a MetaData object the TextTerm represents\nthe label for the positive orientation of the feature the MetaData\ndescribes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source:</strong>  Can be a TextTerm instance, string, or MetaData object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A TextTerm instance constructed from the source.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  If source type is not supported.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.TextTerm.and_", "modulename": "tangles_tot.features", "qualname": "TextTerm.and_", "kind": "function", "doc": "<p>Combine two terms with logical AND operation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other_term:</strong>  The other TextTerm instance to combine with.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new TextTerm representing the AND combination.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">other_term</span><span class=\"p\">:</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.TextTerm.or_", "modulename": "tangles_tot.features", "qualname": "TextTerm.or_", "kind": "function", "doc": "<p>Combine two terms with logical OR operation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other_term:</strong>  The other TextTerm instance to combine with.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new TextTerm representing the OR combination.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">other_term</span><span class=\"p\">:</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.TextTerm.not_", "modulename": "tangles_tot.features", "qualname": "TextTerm.not_", "kind": "function", "doc": "<p>Negate the current term.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new TextTerm representing the negation.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.TextTerm.true", "modulename": "tangles_tot.features", "qualname": "TextTerm.true", "kind": "function", "doc": "<p>Return a TextTerm representing 'true'.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A TextTerm instance with text set to 'true'.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.TextTerm.false", "modulename": "tangles_tot.features", "qualname": "TextTerm.false", "kind": "function", "doc": "<p>Return a TextTerm representing 'false'.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A TextTerm instance with text set to 'false'.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.interpret_feature", "modulename": "tangles_tot.features", "qualname": "interpret_feature", "kind": "function", "doc": "<p>Interpret a feature of a feature system by representing it as a logical term.</p>\n\n<p>Very helpful if we added new corners to a FeatureSystem and we are curious about how we can\ndescribe these corners using the features we originally added to the FeatureSystem.</p>\n\n<p>This method reconstructs a logical term which describes how it is possible to use the\nstatements of the original features to obtain the same statement as the corner feature.</p>\n\n<p>For example if feature is the intersection of original_feature[:, 0] with metadata \"A\" and\noriginal_feature[:, 1] with metadata \"B\" then feature would be represented by the statement\n\"A and B\".</p>\n\n<p>If we were to condition this statement under the statement \"A\", by putting original_feature[:, 0] into\nthe under_condition argument, the output would be B since we assume A to be true from the beginning.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>feature:</strong>  The feature to interpret.</li>\n<li><strong>feat_sys:</strong>  The feature system containing information about all features.</li>\n<li><strong>under_condition:</strong>  Optional list of features. If provided condition the output statement on all of the feature being true.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A TextTerm representing the reconstructed logical interpretation of the feature.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feature</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">feat_sys</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">tangles</span><span class=\"o\">.</span><span class=\"n\">separations</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">_set_system</span><span class=\"o\">.</span><span class=\"n\">FeatureSystem</span><span class=\"p\">,</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">uncrossing_feature_system</span><span class=\"o\">.</span><span class=\"n\">UncrossingFeatureSystem</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">under_condition</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.features.interpret_feature_array", "modulename": "tangles_tot.features", "qualname": "interpret_feature_array", "kind": "function", "doc": "<p>Interpret a feature array by representing it as a logical term.</p>\n\n<p>The original features can be interpretet as statements (whose names are given by the metadata)\nwhich elements of the groundset either have (if the corresponding value is 1) or not have\n(if the corresponding value is -1).</p>\n\n<p>Suppose feature was constructed from the original features from a combination of intersections,\nunions and complements of the original features.</p>\n\n<p>This method reconstructs a logical term which describes how it is possible to use the\nstatements of the original features to obtain the same statement as the new feature.</p>\n\n<p>For example if feature is the intersection of original_feature[:, 0] with metadata \"A\" and\noriginal_feature[:, 1] with metadata \"B\" then feature would be represented by the statement\n\"A and B\".</p>\n\n<p>If we were to condition this statement under the statement \"A\", by putting original_feature[:, 0] into\nthe under_condition argument, the output would be B since we assume A to be true from the beginning.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>feature:</strong>  The feature to interpret.</li>\n<li><strong>original_features:</strong>  Array of features which are labeled for reference.</li>\n<li><strong>metadata:</strong>  List containing labels for each feature.</li>\n<li><strong>under_condition:</strong>  Optional feature. If provided condition the output statement on the under_condition feature being true.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A TextTerm representing the reconstructed logical interpretation of the feature.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feature</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">original_features</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">metadata</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span><span class=\"p\">,</span> <span class=\"n\">tangles</span><span class=\"o\">.</span><span class=\"n\">separations</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">_set_system_base</span><span class=\"o\">.</span><span class=\"n\">MetaData</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">under_condition</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">features</span><span class=\"o\">.</span><span class=\"n\">logic</span><span class=\"o\">.</span><span class=\"n\">TextTerm</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.plot", "modulename": "tangles_tot.plot", "kind": "module", "doc": "<p>A module providing functions and tools for visualising and plotting trees of tangles.</p>\n"}, {"fullname": "tangles_tot.plot.plot_feature_tree", "modulename": "tangles_tot.plot", "qualname": "plot_feature_tree", "kind": "function", "doc": "<p>Plot the tree structure of the feature tree.</p>\n\n<p>The edges of the plotted tree correspond to the features in the feature tree.\nIf the features are not specified, i.e. they are potential features,\nthen neither are the edges of the tree are undirected.\nIf the features are specified, then the edges are directed - pointing\ntowards the feature.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>feature_tree:</strong>  The feature tree to plot.</li>\n<li><strong>ax:</strong>  Optional matplotlib axis object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feature_tree</span><span class=\"p\">:</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureTree</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.plot.NXTree", "modulename": "tangles_tot.plot", "qualname": "NXTree", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Union[networkx.classes.graph.Graph, networkx.classes.digraph.DiGraph]"}, {"fullname": "tangles_tot.plot.feature_tree_to_nx", "modulename": "tangles_tot.plot", "qualname": "feature_tree_to_nx", "kind": "function", "doc": "<p>Builds a networkx graph representation of a FeatureTree.</p>\n\n<p>If the features in the feature_tree are unspecified, i.e. they are potential features, then\nthe graph object is a nx.Graph object. If the features are specified then a directed graph\nis returned.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>feature_tree:</strong>  The feature tree to turn into a network graph (or directed graph) object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A networkx graph object which can be used to plot a graph representation of the feature tree.\n  The nodes are the index of the node in the feature_tree, furthermore they have associated_tangle\n  and label attributes.\n  The edges have a feature_id attribute and a label attribute.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feature_tree</span><span class=\"p\">:</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureTree</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">networkx</span><span class=\"o\">.</span><span class=\"n\">classes</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">,</span> <span class=\"n\">networkx</span><span class=\"o\">.</span><span class=\"n\">classes</span><span class=\"o\">.</span><span class=\"n\">digraph</span><span class=\"o\">.</span><span class=\"n\">DiGraph</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.plot.plot_tree_of_tangles", "modulename": "tangles_tot.plot", "qualname": "plot_tree_of_tangles", "kind": "function", "doc": "<p>Plot the tree structure of a tree of tangles.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>feature_tree:</strong>  The tree of tangles or feature tree to plot.</li>\n<li><strong>ax:</strong>  Optional matplotlib axis object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tree</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">tree_of_tangles</span><span class=\"o\">.</span><span class=\"n\">TreeOfTangles</span><span class=\"p\">,</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureTree</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search", "modulename": "tangles_tot.search", "kind": "module", "doc": "<p>Package containing functionality for searching for trees of tangles.</p>\n"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem", "kind": "class", "doc": "<p>A class which implements the functionality of a feature system and is additionally\nspecialised for use cases involving uncrossing.</p>\n\n<p>Currently it manages a list of feature ids of the features which were not added by\ncorners, the \"original ids\".</p>\n\n<p>Still very unstable and will probably change a lot between releases.</p>\n"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.__init__", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feat_sys</span><span class=\"p\">:</span> <span class=\"n\">tangles</span><span class=\"o\">.</span><span class=\"n\">separations</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">_set_system</span><span class=\"o\">.</span><span class=\"n\">FeatureSystem</span>,</span><span class=\"param\">\t<span class=\"n\">original_ids</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.with_array", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.with_array", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">metadata</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">uncrossing_feature_system</span><span class=\"o\">.</span><span class=\"n\">UncrossingFeatureSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.from_feature_system", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.from_feature_system", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feat_sys</span><span class=\"p\">:</span> <span class=\"n\">tangles</span><span class=\"o\">.</span><span class=\"n\">separations</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">_set_system</span><span class=\"o\">.</span><span class=\"n\">FeatureSystem</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">uncrossing_feature_system</span><span class=\"o\">.</span><span class=\"n\">UncrossingFeatureSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.add_corner", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.add_corner", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification_a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_b</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification_b</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.compute_infimum", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.compute_infimum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feat_ids</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">specifications</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.get_number_of_original_features", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.get_number_of_original_features", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.get_original_features", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.get_original_features", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.get_feature", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.get_feature", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.get_metadata_of_original_features", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.get_metadata_of_original_features", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.count_big_side", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.count_big_side", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">feature_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.side_counts", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.side_counts", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">feature_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.feature_size", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.feature_size", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">feature_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.feature_and_complement_size", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.feature_and_complement_size", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">feature_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.all_feature_ids", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.all_feature_ids", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.get_feature_ids", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.get_feature_ids", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.is_nested", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.is_nested", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">feature_id_1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">feature_id_2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.feature_metadata", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.feature_metadata", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature_ids</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles</span><span class=\"o\">.</span><span class=\"n\">separations</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">_set_system_base</span><span class=\"o\">.</span><span class=\"n\">MetaData</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.is_le", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.is_le", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification_1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_2</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification_2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.is_subset", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.is_subset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification_1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_2</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification_2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.add_features", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.add_features", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">metadata</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.get_corners", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.get_corners", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id_2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.search.UncrossingFeatureSystem.copy", "modulename": "tangles_tot.search", "qualname": "UncrossingFeatureSystem.copy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">uncrossing_feature_system</span><span class=\"o\">.</span><span class=\"n\">UncrossingFeatureSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree", "modulename": "tangles_tot.tree", "kind": "module", "doc": "<p>Package containing the core tree of tangles objects.</p>\n"}, {"fullname": "tangles_tot.tree.build_tree_of_tangles_from_sweep", "modulename": "tangles_tot.tree", "qualname": "build_tree_of_tangles_from_sweep", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tangle_sweep</span><span class=\"p\">:</span> <span class=\"n\">tangles</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">_sweep</span><span class=\"o\">.</span><span class=\"n\">TangleSweep</span>,</span><span class=\"param\">\t<span class=\"n\">agreement_value</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">tree_of_tangles</span><span class=\"o\">.</span><span class=\"n\">TreeOfTangles</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.TreeOfTangles", "modulename": "tangles_tot.tree", "qualname": "TreeOfTangles", "kind": "class", "doc": "<p>A tree of tangles.</p>\n\n<h6 id=\"attribute\">Attribute:</h6>\n\n<blockquote>\n  <p>feature_tree: A FeatureTree containing the (unspecified) features of the tree of tangles.</p>\n</blockquote>\n\n<h6 id=\"note\">Note:</h6>\n\n<blockquote>\n  <p>TreeOfTangles are not intended to be built using the constructor but instead by using\n  one of the factory methods.</p>\n</blockquote>\n"}, {"fullname": "tangles_tot.tree.TreeOfTangles.feature_tree", "modulename": "tangles_tot.tree", "qualname": "TreeOfTangles.feature_tree", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tangles_tot.tree.TreeOfTangles.default_specification", "modulename": "tangles_tot.tree", "qualname": "TreeOfTangles.default_specification", "kind": "function", "doc": "<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A FeatureTree with every feature being specified by its default specification (1).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureTree</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree", "modulename": "tangles_tot.tree", "qualname": "FeatureTree", "kind": "class", "doc": "<p>Encodes the tree structure of a set of nested features.</p>\n\n<p>Consists of nodes which are Locations, connected by FeatureEdges.</p>\n\n<p>The FeatureEdges correspond to the nested features.</p>\n"}, {"fullname": "tangles_tot.tree.FeatureTree.__init__", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">_edges</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureEdge</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">_locations</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">Location</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">_locations_of_edge</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">Location</span><span class=\"p\">,</span> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">Location</span><span class=\"p\">]]</span></span>)</span>"}, {"fullname": "tangles_tot.tree.FeatureTree.feature_ids", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.feature_ids", "kind": "function", "doc": "<p>The feature ids of the nested features in the feature tree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.get_edge", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.get_edge", "kind": "function", "doc": "<p>Get the edge corresponding to the id of a feature.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Either a FeatureEdge if one exists or None if the id of the feature is\n  not contained in the feature_ids of the FeatureTree.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureEdge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.edges", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.edges", "kind": "function", "doc": "<p>Returns a list of all of the edges of the FeatureTree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureEdge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.locations", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.locations", "kind": "function", "doc": "<p>Returns a list of all of the nodes of the FeatureTree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">Location</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.get_location", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.get_location", "kind": "function", "doc": "<p>Gets a location of the FeatureTree either using a node index or a tangle id.</p>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li>Value error if both node_idx and tangle_id or either are specified.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A Location if a matching location exists and None otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node_idx</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tangle_id</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">Location</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.get_location_containing", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.get_location_containing", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">Location</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.get_node_idx_of_location_containing", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.get_node_idx_of_location_containing", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">feature</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureTree.with_specification", "modulename": "tangles_tot.tree", "qualname": "FeatureTree.with_specification", "kind": "function", "doc": "<p>Returns a new FeatureTree without specifications, only containing non-specified\npartitions if no specification is provided, otherwise orients the\nfeatures as specified in the specifiecation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>specification:</strong>  Either None or a dictionary mapping EVERY feature id to a specification.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a new FeatureTree.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">specification</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tangles_tot</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">feature_tree</span><span class=\"o\">.</span><span class=\"n\">FeatureTree</span>:</span></span>", "funcdef": "def"}, {"fullname": "tangles_tot.tree.FeatureEdge", "modulename": "tangles_tot.tree", "qualname": "FeatureEdge", "kind": "class", "doc": "<p>An edge of a FeatureTree, corresponds either to a potential\nfeature, a partition, if the specification is None, or\nto a feature with given specification.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>feature_id:</strong>  the feature id of the edge.</li>\n<li><strong>specification:</strong>  either None or the specification of the feature.</li>\n<li><strong>label:</strong>  a description of the feature.</li>\n</ul>\n"}, {"fullname": "tangles_tot.tree.FeatureEdge.__init__", "modulename": "tangles_tot.tree", "qualname": "FeatureEdge.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">feature_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">specification</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "tangles_tot.tree.FeatureEdge.feature_id", "modulename": "tangles_tot.tree", "qualname": "FeatureEdge.feature_id", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "tangles_tot.tree.FeatureEdge.specification", "modulename": "tangles_tot.tree", "qualname": "FeatureEdge.specification", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Union[Literal[1], Literal[-1], NoneType]"}, {"fullname": "tangles_tot.tree.FeatureEdge.label", "modulename": "tangles_tot.tree", "qualname": "FeatureEdge.label", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "tangles_tot.tree.Location", "modulename": "tangles_tot.tree", "qualname": "Location", "kind": "class", "doc": "<p>A node of a FeatureTree, corresponds to a location, the minimal features\ncontained in the pre-tangles of the partitions contained in the FeatureTree.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>features:</strong>  the list of minimal features.</li>\n<li><strong>associated_tangle:</strong>  Optionally contains the tangle id of the (unique) maximal tangle which contains the features of this location.</li>\n<li><strong>node_idx:</strong>  The index of the node in the FeatureTree.</li>\n<li><strong>label:</strong>  a description of the location.</li>\n</ul>\n"}, {"fullname": "tangles_tot.tree.Location.__init__", "modulename": "tangles_tot.tree", "qualname": "Location.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]]]</span>,</span><span class=\"param\">\t<span class=\"n\">associated_tangle</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">node_idx</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "tangles_tot.tree.Location.features", "modulename": "tangles_tot.tree", "qualname": "Location.features", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[tuple[int, typing.Union[typing.Literal[1], typing.Literal[-1]]]]"}, {"fullname": "tangles_tot.tree.Location.associated_tangle", "modulename": "tangles_tot.tree", "qualname": "Location.associated_tangle", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Union[str, int, NoneType]"}, {"fullname": "tangles_tot.tree.Location.node_idx", "modulename": "tangles_tot.tree", "qualname": "Location.node_idx", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "tangles_tot.tree.Location.label", "modulename": "tangles_tot.tree", "qualname": "Location.label", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "examples", "modulename": "examples", "kind": "module", "doc": "<h1 id=\"tree-of-tangles\">Tree of Tangles</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">tangles_tot._testing.feature_trees</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">three_star</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">tangles_tot.plot</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">plot_tree_of_tangles</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">tangles_tot.tree</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">TreeOfTangles</span>\n\n<span class=\"n\">tree_of_tangles</span> <span class=\"o\">=</span> <span class=\"n\">TreeOfTangles</span><span class=\"p\">(</span><span class=\"n\">three_star</span><span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"n\">plot_tree_of_tangles</span><span class=\"p\">(</span><span class=\"n\">tree_of_tangles</span><span class=\"o\">.</span><span class=\"n\">default_specification</span><span class=\"p\">())</span>\n</code></pre>\n</div>\n\n<p><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgMAAAGFCAYAAABg2vAPAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAQzxJREFUeJzt3Xd8VFX+//HXTAppECC0UGJo0pEiRkoIHaWDilITEQFRVnddFVwRouBvEXcRURdEl4yAUqQIWAClKkpVpC6JlAQDgQRIIySZmfv7gy+jkZKIIRNy38/Hw8fD3JbPJGTOe8499xyLYRgGIiIiYlpWdxcgIiIi7qUwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJudZkIOcTieJiYmULl0ai8Vyq2sSERGRQmAYBunp6VStWhWr9fqf/wsUBhITE6lRo0ahFSciIiJFJyEhgerVq193f4HCQOnSpV0XK1OmTOFUJiIiIrdUWloaNWrUcLXj11OgMHDl1kCZMmUUBkRERG4z+d3i1wBCERERk1MYEBERMTmFAREREZNTGBARETE5hQERERGTUxgQERExOYUBERERk1MYEBERMTmFAREREZNTGBARETE5hQERERGTUxgQERExOYUBERERk1MYEBERMTmFAREREZNTGBARETE5T3cXICLuk5lt53hKJjl2J96eVkKD/PEvpbcFEbPRX72IycQmpbNwezwb/3eG+HMXMX6zzwKElPejY71KDAkLoW7l0u4qU0SKkMUwDCO/g9LS0ggMDCQ1NZUyZcoURV0iUsgSzl3kxRX72BqXjIfVgsN5/T/9K/vD61Tgtf5NqFHerwgrFZHCUtD2W2MGRExg0c54uszYzLajKQA3DAK/3b/taApdZmxm0c74W16jiLiPbhOIlHBvb4zljXVHbupch9PA4TQYv3wfyRnZPNWxbiFXJyLFgXoGREqwRTvjbzoI/N4b646wWD0EIiWSwoBICZVw7iKTVh0o1Gu+vOoACecuFuo1RcT9FAZE3Gzbtm1MnjyZCxcuFOp1X1yxD3s+YwNu5MLWhZz4Z6882+xOgxdX7Lvpa7700kv06tWLatWqYbFYiIqKuulriUjhURgQcbNt27YRHR1dqGEgNimdrXHJ+Q4U/KMcToOtccnEnUm/qfNnzJhBSkoKffr0wdvbu1BrE5GbpzAgUgIt3B6Ph9VyS67tYbWw4PubGzuQnp7Od999x3/+8x+8vLwKuTIRuVkKAyJuNHnyZJ577jkAatasicViwWKxsGnTJgAWL15Mt27dCA4OxtfXlwYNGjB+/HgyMzPzXCcqKoqAgADi4uLo0aMHrz50NydmRXLu6/cx7Ll5jrWnJXN2xWvE//sh4mc8zNlV08k+dYQT/+xFxk9f5Vtz2oHN/HvcQPz9/QkICKB79+788MMPBXq9VqveckSKIz1aKOJGI0eO5Ny5c8yaNYvly5cTHBwMQMOGDQGIjY2lR48ePPPMM/j7+3P48GGmTZvGjh072LBhQ55r5ebm0qdPH4ZGPsqewLZcSjhA6reLsJbyp2y7QQA4cy6R9PEEnFkZlOsQhWe5YLKO7iZ55bQC1Zu6bQkXtswnoGkXPpz5/7AaDqZPn054eDg7duxw1S0itxeFARE3ql69OiEhIQA0b96c0NDQPPtfeukl1/8bhkHbtm1p0KABERER/PTTTzRt2tS1Pycnh+joaBq27cZ7F77BJ7QZOadjyTy42RUGMvd/jf38KSoNjMa3VksAfGu2ICU3m4wfv7xhrfa0s1z4ZiGlW/aifNfR1L+nHY2qBtK1a1fq1q1LdHQ0ixcvLowfi4gUMfXZiRRjR48eZfDgwVSpUgUPDw+8vLyIiIgA4NChQ3mOtVgs9O7dmxy707XNq2IojrQzrq8vxe/H4u3rCgJX+DeMyLeWrGN7wOnAv3EnDKeDi5dysNvt+Pj4EBER4bq1ISK3H/UMiBRTGRkZhIeH4+Pjw5QpU7jzzjvx8/MjISGBAQMGkJWVled4Pz8/fHx88PbMdm2zeHhh2HNcXzuz0vDwL3vV97rWtt9zZl4A4LTtrwDc83re/RoPIHL7UhgQKaY2bNhAYmIimzZtcvUGAPk+ghga5I8FuNZDhVbfMjhOXT0joSPjfL71WH0vL3JSod8EvAIrsXjUvfh66y1EpCTQX7KIm5UqVQrgqk/6Foslz/4r5syZc8Pr+ZfyJKS8HyeuMVOgT0hjLh7eStbPu/Ctfbdre+ahLfnW6VuzBVg9sF84RcO2XQlvc2++54jI7UFhQMTNmjRpAsDMmTOJjIzEy8uLevXq0aZNG8qVK8eYMWOYNGkSXl5eLFy4kL179+Z7zY71KjF/+4mrtvs37kzazpUkr/4XZdsP+7+nCXaRdez/Hg20XH9uAs+ylSkbPoQLW+aTWSqTlXVSKVeuHElJSezYsQN/f3+io6NvWNfmzZs5e/YsAA6HgxMnTvDJJ58AEBERQcWKFfN9bSJS+HSTT8TNOnTowIQJE1i9ejXt2rWjVatW7N69m6CgID777DP8/PwYOnQoI0aMICAgoEAj9oeEhVxz9kGrtw+VB72GT0gTzm+ax9kVr+FIO0tQtycu7/cJuOF1A1sPpGK/CXhlJBEZGUn37t15/vnnOXHiBO3bt8+3rkmTJvHQQw/x0EMPcenSJTZt2uT6+sCBwl1HQUQKzmIYRr7zlaalpREYGEhqaiplypQpirpE5E8a9sF2th1NKdCUxFfmD6g2dh6eZSpc9zgPq4U2tYKY/1hYYZYqIrdIQdtv3SYQKaFe69+ELjM2XxUG0navBsArqAY47Fw68RNpu1fh36jDDYMAgKfVwmv9m9yymkXEPRQGREqoGuX9iO7TiPHL864yaPUsRdquT7GnnsGw5+JZpiKBYQ8S2PbhfK/5Sp9G1Cjvd6tKFhE3URgQKcEeaRVCckY2b6z79XHCgLu6EXBXtz98ree61ePhViGFWZ6IFBMKAyIl3FMd61IhoBSTVh3A7jT+0LLGHlYLnlYLr/RppCAgUoLpaQIRE3ikVQhf/TWCNrWCAPJd3vjK/ja1gvjqrxEKAiIlnHoGREyiRnk/5j8WRmxSOgu3x7PxyBniUy7mmanQAoQE+dHxzkoMvTeEOpVKu6tcESlCerRQxMQys+30G/Y4hsWDmTP+RWiQP/6l9BlBpKTQo4Uiki//Up74XkoBoFHVQDdXIyLuojEDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiImpzAgIiJicgoDIiIiJqcwICIiYnIKAyIiIianMCAiImJyCgMiIiIm5+nuAkTEvR588EF3lyAibqYwIGJygwcPdncJIuJmCgMiJufpqbcBEbPTmAERERGTUxgQERExOYUBERERk1MYEBERMTmFARHJIz09nUcffdTdZYhIEdIwYhGTmjlz5jW3p6enY7PZaNmyJXXq1OG+++4r4spEpKhZDMMw8jsoLS2NwMBAUlNTKVOmTFHUJSK3WK1ata653eFwcPLkSUJCQjh16hTDhw/nvffeK+LqRKQwFLT9VhgQkTzOnj1L5cqVcTqdbN++nR49epCSkuLuskTkJhS0/daYARHJw2q1EhoaCkDNmjW5cOGCW+sRkVtPYwZETC4jI4ODBw9itVpp2LAhQUFBHD16FIAKFSrwww8/uLlCEbnV1DMgYmITJ06kYsWK3Hvvvdxzzz1UqFCBf/zjH679VquVpk2burFCESkKCgMiJvX2228zZ84c3n//fbZs2UJAQAAbN25k5cqVvP766+4uT0SKkMKAiEm9++67vPHGGwwZMoSqVatiGAZhYWHMnDmTOXPmuLs8ESlCCgMiJnX06FHatWt31fY6depw6tQpN1QkIu6iMCBiUmXLliUtLe2q7Vu2bKFevXpuqEhE3EVhQMSkWrRowbZt21xf5+bm8vjjjzNmzBheeuklN1YmIkVNjxaKmNSLL77IsWPHAChVqhTNmzcnKyuLtWvXEh4e7ubqRKQo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\" alt=\"png\" /></p>\n\n<h1 id=\"interpret-corners\">Interpret Corners</h1>\n\n<p>After uncrossing the efficient distinguishers with the tree of tangles algorithm we often have the problem of the efficient distinguishers not being features we originally added to the feature system but instead corners, or even worse, corners of corners of corners... </p>\n\n<p>Interpreting these corners can be a challenge, especially since tracking which corners we intersected to obtain a certain efficient distinguisher leads to complicated and highly redundant descriptions.</p>\n\n<p>The tangles_tot library provides some tools to make it easier to interpret these corners by reconstructing a, hopefully, more simple description of features, in terms of intersections, unions and complements of the features originally added to the feature system. </p>\n\n<h2 id=\"features-and-logic-terms\">Features and Logic Terms</h2>\n\n<p>We translate the concept of features, intersection, union and complement into the language of logic. </p>\n\n<p>We can associate a feature $A \\subseteq V$ with the statement $v \\in A$. For simplicity we describe this statement\nsimply by $A$. The inverse feature $V \\setminus A$ can therefore be described by the statement $\\lnot A$. \nSimilarly the intersection $A \\cap B$ of two features $A, B \\subseteq V$ can be described by $A \\land B$ and \nsimilarly the union $A \\cup B$ by $A \\lor B$. </p>\n\n<p>In this way the logic terms give us an interpretation of the meaning behind the efficient distinguisher features. </p>\n\n<h2 id=\"reconstructing-features\">Reconstructing Features</h2>\n\n<p>Let us start with a simple example showing how the tool can be used.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">tangles_tot.features</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">interpret_feature</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">tangles.separations.system</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">FeatureSystem</span>\n\n<span class=\"c1\"># building a feature system feat_sys which contains two features: A and B</span>\n<span class=\"n\">features</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span>\n    <span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]],</span>\n<span class=\"p\">)</span>\n<span class=\"n\">metadata</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&quot;A&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;B&quot;</span><span class=\"p\">]</span>\n<span class=\"n\">feat_sys</span> <span class=\"o\">=</span> <span class=\"n\">FeatureSystem</span><span class=\"o\">.</span><span class=\"n\">with_array</span><span class=\"p\">(</span><span class=\"n\">features</span><span class=\"p\">,</span> <span class=\"n\">metadata</span><span class=\"o\">=</span><span class=\"n\">metadata</span><span class=\"p\">)</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">feat_sys</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<pre><code>2\n</code></pre>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">corner_ids</span><span class=\"p\">,</span> <span class=\"n\">corner_specifications</span> <span class=\"o\">=</span> <span class=\"n\">feat_sys</span><span class=\"o\">.</span><span class=\"n\">get_corners</span><span class=\"p\">(</span>\n    <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n<span class=\"p\">)</span>  <span class=\"c1\"># adding two corners to feat_sys</span>\n<span class=\"c1\"># the index 3 corresponds to the infimum of (0, 1) and (1, 1)</span>\n<span class=\"n\">a_and_b</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">corner_ids</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"n\">corner_specifications</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">])</span>\n<span class=\"c1\"># the index 0 corresponds to the infimum of (0, -1) and (1, -1), the inverse of &quot;a or b&quot;</span>\n<span class=\"n\">a_or_b</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">corner_ids</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"n\">corner_specifications</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;a and b&quot;</span><span class=\"p\">,</span> <span class=\"n\">a_and_b</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;a or b&quot;</span><span class=\"p\">,</span> <span class=\"n\">a_or_b</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<pre><code>a and b (np.int64(5), np.int8(1))\na or b (np.int64(2), np.int8(-1))\n</code></pre>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;(0, 1)&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;(0, -1)&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;(1, 1)&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;(1, -1)&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;a and b&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"n\">a_and_b</span><span class=\"p\">),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;inverse of (a and b)&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"n\">a_and_b</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"n\">a_and_b</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;a or b&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"n\">a_or_b</span><span class=\"p\">),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;inverse of (a or b)&quot;</span><span class=\"p\">,</span> <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"n\">a_or_b</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"n\">a_or_b</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"n\">feat_sys</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<pre><code>(0, 1) A\n(0, -1) \u00acA\n(1, 1) B\n(1, -1) \u00acB\na and b A \u2227 B\ninverse of (a and b) \u00acB \u2228 \u00acA\na or b A \u2228 B\ninverse of (a or b) \u00acA \u2227 \u00acB\n</code></pre>\n\n<h2 id=\"conditional-features\">Conditional Features</h2>\n\n<p>While already helpful the previous terms can still grow quite long in practical tree of tangles. To allow for some simplification we introduce another method. This method allows us to calculate conditional features. Let us show what we mean by an example.</p>\n\n<p>Suppose we have a tree of tangles consisting of the three nested features $A \\cap B \\leq A \\leq A \\cup B$. Then we could take $A$ as a \"baseline\" and consider for $A \\cap B$ what it does _in addition_ to $A$, which, translated to the language of logic means that we look for a statement which is equal to $A \\cup B$ under the condition that we know that $A$ is true. </p>\n\n<p>Similarly for the other feature $A \\cup B$ under the condition $A$ is not interesting, as this is always true. But for their inverses $V \\setminus (A \\cup B)$ under the condition $A$ is $\\lnot B$.  </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"nb\">print</span><span class=\"p\">(</span>\n    <span class=\"s2\">&quot;a and b under condition a   &quot;</span><span class=\"p\">,</span>\n    <span class=\"n\">interpret_feature</span><span class=\"p\">(</span><span class=\"n\">a_and_b</span><span class=\"p\">,</span> <span class=\"n\">feat_sys</span><span class=\"p\">,</span> <span class=\"n\">under_condition</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)]),</span>\n<span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span>\n    <span class=\"s2\">&quot;a or b under condition a   &quot;</span><span class=\"p\">,</span>\n    <span class=\"n\">interpret_feature</span><span class=\"p\">(</span><span class=\"n\">a_or_b</span><span class=\"p\">,</span> <span class=\"n\">feat_sys</span><span class=\"p\">,</span> <span class=\"n\">under_condition</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)]),</span>\n<span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span>\n    <span class=\"s2\">&quot;not (a or b) under condition not a   &quot;</span><span class=\"p\">,</span>\n    <span class=\"n\">interpret_feature</span><span class=\"p\">((</span><span class=\"n\">a_or_b</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"n\">a_or_b</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"n\">feat_sys</span><span class=\"p\">,</span> <span class=\"n\">under_condition</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)]),</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<pre><code>a and b under condition a    B\na or b under condition a    true\nnot (a or b) under condition not a    \u00acB\n</code></pre>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();